{
  "custompage": {
    "metadata": {
      "image": [],
      "title": "",
      "description": "",
      "keywords": ""
    },
    "algolia": {
      "recordCount": 9,
      "publishPending": false,
      "updatedAt": "2024-07-11T01:20:22.562Z"
    },
    "title": "Creating a QA Bot From Technical Documentation",
    "slug": "creating-a-qa-bot",
    "body": "[block:html]\n{\n  \"html\": \"<div class=\\\"cookbook-nav-container\\\">\\n  <a href=\\\"/page/cookbooks\\\" class=\\\"back-button pt-10 group inline-block cursor-pointer font-medium \\\" rel=\\\"noreferrer\\\"\\n    target=\\\"_self\\\">\\n    <div class=\\\"pr-1 inline-block group-hover:no-underline\\\">\\n      <svg width=\\\"11.8\\\" height=\\\"11\\\" viewBox=\\\"0 0 14 13\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path\\n          d=\\\"M1.1554 7.20808C1.35066 7.40335 1.66724 7.40335 1.8625 7.20808L7.18477 1.88582C7.38003 1.69055 7.38003 1.37397 7.18477 1.17871L6.83121 0.825157C6.63595 0.629895 6.31937 0.629896 6.12411 0.825157L0.801842 6.14742C0.60658 6.34269 0.60658 6.65927 0.801842 6.85453L1.1554 7.20808Z\\\"\\n          fill=\\\"currentColor\\\" />\\n        <path\\n          d=\\\"M1.1554 5.79226C1.35066 5.597 1.66724 5.597 1.8625 5.79226L7.18477 11.1145C7.38003 11.3098 7.38003 11.6264 7.18477 11.8216L6.83121 12.1752C6.63595 12.3705 6.31937 12.3705 6.12411 12.1752L0.801842 6.85292C0.60658 6.65766 0.60658 6.34108 0.801842 6.14582L1.1554 5.79226Z\\\"\\n          fill=\\\"currentColor\\\" />\\n        <path\\n          d=\\\"M2.52491 6.23674C2.52492 5.9606 2.74878 5.73675 3.02491 5.73675H6.28412C6.4513 5.73675 6.60742 5.8203 6.70015 5.95941L7.03347 6.45941C7.25499 6.79169 7.01679 7.23675 6.61745 7.23675H3.0249C2.74876 7.23675 2.5249 7.01289 2.5249 6.73674L2.52491 6.23674Z\\\"\\n          fill=\\\"currentColor\\\" />\\n        <path\\n          d=\\\"M13.5517 6.73676C13.5517 7.0129 13.3278 7.23675 13.0517 7.23675H8.79246C8.62528 7.23675 8.46916 7.1532 8.37643 7.0141L8.04311 6.5141C7.8216 6.18182 8.05979 5.73675 8.45914 5.73675H13.0517C13.3278 5.73675 13.5517 5.96062 13.5517 6.23676L13.5517 6.73676Z\\\"\\n          fill=\\\"currentColor\\\" />\\n      </svg>\\n    </div>\\n    Back to Cookbooks\\n  </a>\\n\\n  <a href=https://github.com/cohere-ai/notebooks/blob/main/notebooks/guides/Creating_a_QA_bot_from_technical_documentation.ipynb class=\\\"github-button pt-10 group inline-block cursor-pointer font-medium \\\" rel=\\\"noreferrer\\\"\\n    target=\\\"_blank\\\">\\n    Open in GitHub\\n    <div class=\\\"pl-1 inline-block group-hover:no-underline\\\">\\n      <svg width=\\\"14\\\" height=\\\"10\\\" viewBox=\\\"0 0 14 10\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path\\n          d=\\\"M8.63218 0.366821C8.35604 0.366821 8.13218 0.590679 8.13218 0.866821V8.39364C8.13218 8.66978 8.35604 8.89364 8.63218 8.89364H9.13218C9.40832 8.89364 9.63218 8.66978 9.63218 8.39364V0.866821C9.63218 0.590678 9.40832 0.366821 9.13218 0.366821H8.63218Z\\\"\\n          fill=\\\"currentColor\\\" />\\n        <path\\n          d=\\\"M9.63332 1.36796C9.63332 1.6441 9.40946 1.86796 9.13332 1.86796H1.6065C1.33035 1.86796 1.1065 1.6441 1.1065 1.36796V0.867956C1.1065 0.591813 1.33035 0.367956 1.6065 0.367956H9.13332C9.40946 0.367956 9.63332 0.591813 9.63332 0.867956V1.36796Z\\\"\\n          fill=\\\"currentColor\\\" />\\n        <path\\n          d=\\\"M8.35063 2.02206C8.54588 2.21732 8.54588 2.5339 8.35062 2.72916L6.04601 5.03377C5.9278 5.15198 5.75833 5.20329 5.59439 5.1705L5.00515 5.05264C4.61356 4.97432 4.46728 4.49118 4.74966 4.2088L7.28997 1.66849C7.48523 1.47323 7.80182 1.47323 7.99708 1.6685L8.35063 2.02206Z\\\"\\n          fill=\\\"currentColor\\\" />\\n        <path\\n          d=\\\"M0.199967 9.46558C0.0047119 9.27032 0.0047151 8.95374 0.199974 8.75848L3.21169 5.74677C3.3299 5.62855 3.49938 5.57724 3.66331 5.61003L4.25256 5.72789C4.64414 5.80621 4.79042 6.28935 4.50804 6.57173L1.26063 9.81915C1.06536 10.0144 0.748774 10.0144 0.553513 9.81914L0.199967 9.46558Z\\\"\\n          fill=\\\"currentColor\\\" />\\n      </svg>\\n    </div>\\n  </a>\\n</div>\\n\\n<div>\\n  <h1>Creating a QA Bot From Technical Documentation</h1>\\n</div>\\n\\n<style>\\n  .header {\\n    padding: 9px 0 17px 0;\\n    display: flex;\\n    flex-direction: column;\\n  }\\n\\n  a[href],\\n  .field-description a:not([href=\\\"\\\"]),\\n  .markdown-body a[href],\\n  .markdown-body a:not([href=\\\"\\\"]) {\\n    text-decoration: none;\\n  }\\n\\n  #content {\\n    padding: 0 32px;\\n  }\\n\\n  #content-head {\\n    display: none;\\n  }\\n\\n  .guide-page-title {\\n    font-size: 29px !important;\\n  }\\n\\n  .back-button .github-button {\\n    border-radius: 0 !important;\\n    border-width: 0 !important;\\n    background-color: inherit !important;\\n  }\\n\\n  .cookbook-nav-container {\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: space-between;\\n    align-items: center;\\n  }\\n\\n  @media only screen and (min-width: 620px) {\\n    .guide-page-title {\\n      width: 70%;\\n    }\\n\\n    .header {\\n      display: flex;\\n      flex-direction: row;\\n      align-items: center;\\n      justify-content: space-between;\\n      padding: 9px 0 17px 0;\\n    }\\n\\n    .git--button {\\n      width: 145px !important;\\n      display: flex;\\n      flex-direction: row;\\n      justify-content: center;\\n      align-items: center;\\n      padding: 8px 16px;\\n\\n      width: 154px;\\n      height: 35px;\\n\\n      background: #D4D9D4;\\n      border: 1px solid #9DAAA4;\\n      border-radius: 6px;\\n    }\\n  }\\n\\n\\n  @media only screen and (min-width: 1024px) {\\n    .guide-page-title {\\n      font-size: 46px !important;\\n    }\\n\\n    .header {\\n      padding: 9px 0 32px 0;\\n    }\\n  }\\n</style>\"\n}\n[/block]\n\n\nThis notebook demonstrates how to create a chatbot (single turn) that answers user questions based on technical documentation made available to the model.\n\nWe use the `aws-documentation` dataset ([link](https://github.com/siagholami/aws-documentation/tree/main)) for representativeness. This dataset contains 26k+ AWS documentation pages, preprocessed into 120k+ chunks, and 100 questions based on real user questions.\n\nWe proceed as follows:\n1. Embed the AWS documentation into a vector database using Cohere embeddings and `llama_index`\n2. Build a retriever using Cohere's `rerank` for better accuracy, lower inference costs and lower latency\n3. Create model answers for the eval set of 100 questions\n4. Evaluate the model answers against the golden answers of the eval set\n\n\n## Setup\n\n\n```python\n%%capture\n!pip install cohere datasets llama_index llama-index-llms-cohere llama-index-embeddings-cohere\n```\n\n\n```python\nimport cohere\nimport datasets\nfrom llama_index.core import StorageContext, VectorStoreIndex, load_index_from_storage\nfrom llama_index.core.schema import TextNode\nfrom llama_index.embeddings.cohere import CohereEmbedding\nimport pandas as pd\n\nimport json\nfrom pathlib import Path\nfrom tqdm import tqdm\nfrom typing import List\n\n```\n\n\n```python\napi_key = \"\" # <your API key>\nco = cohere.Client(api_key=api_key)\n```\n\n## 1. Embed technical documentation and store as vector database\n\n* Load the dataset from HuggingFace\n* Compute embeddings using Cohere's implementation in LlamaIndex, `CohereEmbedding`\n* Store inside a vector database, `VectorStoreIndex` from LlamaIndex\n\n\nBecause this process is lengthy (~2h for all documents on a MacBookPro), we store the index to disc for future reuse. We also provide a (commented) code snippet to index only a subset of the data. If you use this snippet, bear in mind that many documents will become unavailable to the model and, as a result, performance will suffer!\n\n\n```python\ndata = datasets.load_dataset(\"sauravjoshi23/aws-documentation-chunked\")\nprint(data)\n\nmap_id2index = {sample[\"id\"]: index for index, sample in enumerate(data[\"train\"])}\n\n```\n\n    /usr/local/lib/python3.10/dist-packages/huggingface_hub/utils/_token.py:88: UserWarning: \n    The secret `HF_TOKEN` does not exist in your Colab secrets.\n    To authenticate with the Hugging Face Hub, create a token in your settings tab (https://huggingface.co/settings/tokens), set it as secret in your Google Colab and restart your session.\n    You will be able to reuse this secret in all of your notebooks.\n    Please note that authentication is recommended but still optional to access public models or datasets.\n      warnings.warn(\n\n\n    DatasetDict({\n        train: Dataset({\n            features: ['id', 'text', 'source'],\n            num_rows: 187147\n        })\n    })\n\n\n\n```python\n\noverwrite = True # only compute index if it doesn't exist\npath_index = Path(\".\") / \"aws-documentation_index_cohere\"\n\nembed_model = CohereEmbedding(\n    cohere_api_key=api_key,\n    model_name=\"embed-english-v3.0\",\n)\n\nif not path_index.exists() or overwrite:\n    # Documents are prechunked. Keep them as-is for now\n    stub_len = len(\"https://github.com/siagholami/aws-documentation/tree/main/documents/\")\n    documents = [\n        # -- for indexing full dataset --\n        TextNode(\n            text=sample[\"text\"],\n            title=sample[\"source\"][stub_len:], # save source minus stub\n            id_=sample[\"id\"],\n        ) for sample in data[\"train\"]\n        # -- for testing on subset --\n        # TextNode(\n        #     text=data[\"train\"][index][\"text\"],\n        #     title=data[\"train\"][index][\"source\"][stub_len:],\n        #     id_=data[\"train\"][index][\"id\"],\n        # ) for index in range(1_000)\n    ]\n    index = VectorStoreIndex(documents, embed_model=embed_model)\n    index.storage_context.persist(path_index)\n\nelse:\n    storage_context = StorageContext.from_defaults(persist_dir=path_index)\n    index = load_index_from_storage(storage_context, embed_model=embed_model)\n\n```\n\n## 2. Build a retriever using Cohere's `rerank`\n\nThe vector database we built using `VectorStoreIndex` comes with an in-built retriever. We can call that retriever to fetch the top $k$ documents most relevant to the user question with:\n\n```python\nretriever = index.as_retriever(similarity_top_k=top_k)\n```\n\nWe recently released [Rerank-3](https://cohere.com/blog/rerank-3/) (April '24), which we can use to improve the quality of retrieval, as well as reduce latency and the cost of inference. To use the retriever with `rerank`, we create a thin wrapper around `index.as_retriever` as follows:\n\n\n```python\nclass RetrieverWithRerank:\n    def __init__(self, retriever, api_key):\n        self.retriever = retriever\n        self.co = cohere.Client(api_key=api_key)\n\n    def retrieve(self, query: str, top_n: int):\n        # First call to the retriever fetches the closest indices\n        nodes = self.retriever.retrieve(query)\n        nodes = [\n            {\n                \"text\": node.node.text,\n                \"llamaindex_id\": node.node.id_,\n            }\n            for node\n            in nodes\n        ]\n        # Call co.rerank to improve the relevance of retrieved documents\n        reranked = self.co.rerank(query=query, documents=nodes, model=\"rerank-english-v3.0\", top_n=top_n)\n        nodes = [nodes[node.index] for node in reranked.results]\n        return nodes\n\n\ntop_k = 60 # how many documents to fetch on first pass\ntop_n = 20 # how many documents to sub-select with rerank\n\nretriever = RetrieverWithRerank(\n    index.as_retriever(similarity_top_k=top_k),\n    api_key=api_key,\n)\n\n```\n\n\n```python\nquery = \"What happens to my Amazon EC2 instances if I delete my Auto Scaling group?\"\n\ndocuments = retriever.retrieve(query, top_n=top_n)\n\nresp = co.chat(message=query, model=\"command-r\", temperature=0., documents=documents)\nprint(resp.text)\n\n```\n\nThis works! With `co.chat`, you get the additional benefit that citations are returned for every span of text. Here's a simple function to display the citations inside square brackets.\n\n\n```python\ndef build_answer_with_citations(response):\n    \"\"\" \"\"\"\n    text = response.text\n    citations = response.citations\n\n    # Construct text_with_citations adding citation spans as we iterate through citations\n    end = 0\n    text_with_citations = \"\"\n\n    for citation in citations:\n        # Add snippet between last citatiton and current citation\n        start = citation.start\n        text_with_citations += text[end : start]\n        end = citation.end  # overwrite\n        citation_blocks = \" [\" + \", \".join([stub[4:] for stub in citation.document_ids]) + \"] \"\n        text_with_citations += text[start : end] + citation_blocks\n    # Add any left-over\n    text_with_citations += text[end:]\n\n    return text_with_citations\n\ngrounded_answer = build_answer_with_citations(resp)\nprint(grounded_answer)\n\n```\n\n## 3. Create model answers for 100 QA pairs\n\nNow that we have a running pipeline, we need to assess its performance.\n\nThe author of the repository provides 100 QA pairs that we can test the model on. Let's download these questions, then run inference on all 100 questions. Later, we will use Command-R+ -- Cohere's largest and most powerful model -- to measure performance.\n\n\n```python\nurl = \"https://github.com/siagholami/aws-documentation/blob/main/QA_true.csv?raw=true\"\nqa_pairs = pd.read_csv(url)\nqa_pairs.sample(2)\n\n```\n\nWe'll use the fields as follows:\n* `Question`: the user question, passed to `co.chat` to generate the answer\n* `Answer_True`: treat as the ground gruth; compare to the model-generated answer to determine its correctness\n* `Document_True`: treat as the (single) golden document; check the rank of this document inside the model's retrieved documents\n\nWe'll loop over each question and generate our model answer. We'll also complete two steps that will be useful for evaluating our model next:\n1. We compute the rank of the golden document amid the retrieved documents -- this will inform how well our retrieval system performs\n2. We prepare the grading prompts -- these will be sent to an LLM scorer to compute the goodness of responses\n\n\n```python\n\nLLM_EVAL_TEMPLATE = \"\"\"## References\n{references}\n\nQUESTION: based on the above reference documents, answer the following question: {question}\nANSWER: {answer}\nSTUDENT RESPONSE: {completion}\n\nBased on the question and answer above, grade the studen't reponse. A correct response will contain exactly \\\nthe same information as in the answer, even if it is worded differently. If the student's reponse is correct, \\\ngive it a score of 1. Otherwise, give it a score of 0. Let's think step by step. Return your answer as \\\nas a compilable JSON with the following structure:\n{{\n    \"reasoning\": <reasoning>,\n    \"score: <score of 0 or 1>,\n}}\"\"\"\n\n\ndef get_rank_of_golden_within_retrieved(golden: str, retrieved: List[dict]) -> int:\n    \"\"\"\n    Returns the rank that the golden document (single) has within the retrieved documents\n    * `golden` contains the source of the document, e.g. 'amazon-ec2-user-guide/EBSEncryption.md'\n    * `retrieved` has a list of responses with key 'llamaindex_id', which links back to document sources\n    \"\"\"\n    # Create {document: rank} map using llamaindex_id (count first occurrence of any document; they can\n    # appear multiple times because they're chunked)\n    doc_to_rank = {}\n    for rank, doc in enumerate(retrieved):\n        # retrieve source of document\n        _id = doc[\"llamaindex_id\"]\n        source = data[\"train\"][map_id2index[_id]][\"source\"]\n        # format as in dataset\n        source = source[stub_len:]  # remove stub\n        source = source.replace(\"/doc_source\", \"\")  # remove /doc_source/\n        if source not in doc_to_rank:\n            doc_to_rank[source] = rank + 1\n\n    # Return rank of `golden`, defaulting to len(retrieved) + 1 if it's absent\n    return doc_to_rank.get(golden, len(retrieved) + 1)\n\n```\n\n\n```python\nfrom tqdm import tqdm\n\nanswers = []\ngolden_answers = []\nranks = []\ngrading_prompts = []  # best computed in batch\n\nfor _, row in tqdm(qa_pairs.iterrows(), total=len(qa_pairs)):\n    query, golden_answer, golden_doc = row[\"Question\"], row[\"Answer_True\"], row[\"Document_True\"]\n    golden_answers.append(golden_answer)\n\n    # --- Produce answer using retriever ---\n    documents = retriever.retrieve(query, top_n=top_n)\n    resp = co.chat(message=query, model=\"command-r\", temperature=0., documents=documents)\n    answer = resp.text\n    answers.append(answer)\n\n    # --- Do some prework for evaluation later ---\n    # Rank\n    rank = get_rank_of_golden_within_retrieved(golden_doc, documents)\n    ranks.append(rank)\n    # Score: construct the grading prompts for LLM evals, then evaluate in batch\n    # Need to reformat documents slightly\n    documents = [{\"index\": str(i), \"text\": doc[\"text\"]} for i, doc in enumerate(documents)]\n    references_text = \"\\n\\n\".join(\"\\n\".join([f\"{k}: {v}\" for k, v in doc.items()]) for doc in documents)\n    # ^ snippet looks complicated, but all it does it unpack all kwargs from `documents`\n    # into text separated by \\n\\n\n    grading_prompt = LLM_EVAL_TEMPLATE.format(\n        references=references_text, question=query, answer=golden_answer, completion=answer,\n    )\n    grading_prompts.append(grading_prompt)\n\n```\n\n## 4. Evaluate model performance\n\nWe want to test our model performance on two dimensions:\n1. How good is the final answer? We'll compare our model answer to the golden answer using Command-R+ as a judge.\n2. How good is the retrieval? We'll use the rank of the golden document within the retrieved documents to this end.\n\nNote that this pipeline is for illustration only. To measure performance in practice, we would want to run more in-depths tests on a broader, representative dataset.\n\n\n```python\nresults = pd.DataFrame()\nresults[\"answer\"] = answers\nresults[\"golden_answer\"] = qa_pairs[\"Answer_True\"]\nresults[\"rank\"] = ranks\n\n```\n\n### 4.1 Compare answer to golden answer\n\nWe'll use Command-R+ as a judge of whether the answers produced by our model convey the same information as the golden answers. Since we've defined the grading prompts earlier, we can simply ask our LLM judge to evaluate that grading prompt. After a little bit of postprocessing, we can then extract our model scores.\n\n\n```python\nscores = []\nreasonings = []\n\ndef remove_backticks(text: str) -> str:\n  \"\"\"\n  Some models are trained to output JSON in Markdown formatting:\n  ```json {json object}```\n  Remove the backticks from those model responses so that they become\n  parasable by json.loads.\n  \"\"\"\n  if text.startswith(\"```json\"):\n      text = text[7:]\n  if text.endswith(\"```\"):\n      text = text[:-3]\n  return text\n\n\nfor prompt in tqdm(grading_prompts, total=len(grading_prompts)):\n  resp = co.chat(message=prompt, model=\"command-r-plus\", temperature=0.)\n  # Convert response to JSON to extract the `score` and `reasoning` fields\n  # We remove backticks for compatibility with different LLMs\n  parsed = json.loads(remove_backticks(resp.text))\n  scores.append(parsed[\"score\"])\n  reasonings.append(parsed[\"reasoning\"])\n\n```\n\n\n```python\nresults[\"score\"] = scores\nresults[\"reasoning\"] = reasonings\n```\n\n\n```python\nprint(f\"Average score: {results['score'].mean():.3f}\")\n\n```\n\n### 4.2 Compute rank\n\nWe've already computed the rank of the golden documents using `get_rank_of_golden_within_retrieved`. Here, we'll plot the histogram of ranks, using blue when the answer scored a 1, and red when the answer scored a 0.\n\n\n```python\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_theme(style=\"darkgrid\", rc={\"grid.color\": \".8\"})\n\nresults[\"rank_shifted_left\"] = results[\"rank\"] - 0.1\nresults[\"rank_shifted_right\"] = results[\"rank\"] + 0.1\n\nf, ax = plt.subplots(figsize=(5, 3))\nsns.histplot(data=results.loc[results[\"score\"] == 1], x=\"rank_shifted_left\", color=\"skyblue\", label=\"Correct answer\", binwidth=1)\nsns.histplot(data=results.loc[results[\"score\"] == 0], x=\"rank_shifted_right\", color=\"red\", label=\"False answer\", binwidth=1)\n\nax.set_xticks([1, 5, 0, 10, 15, 20])\nax.set_title(\"Rank of golden document (max means golden doc. wasn't retrieved)\")\nax.set_xlabel(\"Rank\")\nax.legend();\n\n```\n\nWe see that retrieval works well overall: for 80% of questions, the golden document is within the top 5 documents. However, we also notice that approx. half the false answers come from instances where the golden document wasn't retrieved (`rank = top_k = 20`). This should be improved, e.g. by adding metadata to the documents such as their section headings, or altering the chunking strategy.\n\nThere is also a non-negligible instance of false answers where the top document was retrieved. On closer inspection, many of these are due to the model phrasing its answers more verbosely than the (very laconic) golden documents. This highlights the importance of checking eval results before jumping to conclusions about model performance.\n\n## Conclusions\n\nIn this notebook, we've built a QA bot that answers user questions based on technical documentation. We've learnt:\n\n1. How to embed the technical documentation into a vector database using Cohere embeddings and `llama_index`\n2. How to build a custom retriever that leverages Cohere's `rerank`\n3. How to evaluate model performance against a predetermined set of golden QA pairs",
    "html": "",
    "htmlmode": false,
    "fullscreen": false,
    "hidden": true,
    "revision": 7,
    "_id": "664cbbd2e898970018539365",
    "__v": 0,
    "createdAt": "2024-05-21T15:20:50.442Z",
    "lastUpdatedHash": "922f27c0693a752fb7781b05588706401542a37a",
    "project": "62cde2919aafea009aefb289",
    "updatedAt": "2024-07-11T01:20:22.562Z",
    "user": "5af39863989da435b05d284d"
  },
  "meta": {
    "user": {
      "allowedProjects": ["cohere-ai", "cohere-enterprise"],
      "apiKey": "",
      "email": "andrewjiang@hey.com",
      "name": "Andrew Jiang",
      "version": 1,
      "Name": "Andrew Jiang",
      "Email": "andrewjiang@hey.com",
      "APIKey": "",
      "AllowedProjects": ["cohere-ai", "cohere-enterprise"]
    },
    "baseUrl": "/",
    "hidden": true,
    "title": "Creating a QA Bot From Technical Documentation",
    "metaTitle": "Creating a QA Bot From Technical Documentation",
    "keywords": "",
    "description": "",
    "image": [],
    "slug": "creating-a-qa-bot",
    "type": "custompage",
    "full": false
  }
}
