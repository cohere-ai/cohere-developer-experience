components:
  schemas:
    AssetType:
      enum:
      - page_image
      - page_markdown
      - document_text
      title: AssetType
      type: string
    AzureBlobStorageConfig:
      properties:
        connection_string:
          description: The connection string to the Azure Blob Storage account
          title: Connection String
          type: string
        container_name:
          description: The name of the container in the Azure Blob Storage account
          title: Container Name
          type: string
        name_starts_with:
          anyOf:
          - type: string
          - type: 'null'
          description: The prefix of the blob name to sync
          title: Name Starts With
        type:
          const: msft_azure_blob_storage
          title: Type
          type: string
      required:
      - type
      - connection_string
      - container_name
      title: AzureBlobStorageConfig
      type: object
    ContentTypeEnum:
      enum:
      - text/plain
      - text/html
      - text/csv
      - text/tsv
      - text/x-markdown
      - text/org
      - text/rtf
      - text/x-rst
      - application/json
      - application/jsonl
      - application/json-lines
      - application/pdf
      - application/xml
      - application/msword
      - application/vnd.openxmlformats-officedocument.wordprocessingml.document
      - application/vnd.ms-excel
      - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
      - application/vnd.ms-powerpoint
      - application/vnd.openxmlformats-officedocument.presentationml.presentation
      - application/epub+zip
      - application/vnd.oasis.opendocument.text
      - application/vnd.ms-outlook
      - application/octet-stream
      - image/jpeg
      - image/png
      - image/heic
      - image/tiff
      - image/bmp
      - image/gif
      - image/svg+xml
      - image/webp
      - audio/mpeg
      - audio/x-wav
      - video/mp4
      - video/x-msvideo
      - message/rfc822
      title: ContentTypeEnum
      type: string
    CreateDataSource:
      properties:
        datasource:
          $ref: '#/components/schemas/DataSource'
        state_key:
          anyOf:
          - type: string
          - type: 'null'
          description: The state key used to access the oauth data stored in the cache
          title: State Key
      required:
      - datasource
      title: CreateDataSource
      type: object
    DataSource:
      properties:
        config:
          description: The configuration of the datasource
          discriminator:
            mapping:
              msft_azure_blob_storage: '#/components/schemas/AzureBlobStorageConfig'
              msft_onedrive: '#/components/schemas/OneDriveConfig'
            propertyName: type
          oneOf:
          - $ref: '#/components/schemas/AzureBlobStorageConfig'
          - $ref: '#/components/schemas/OneDriveConfig'
          title: Config
        created_at:
          anyOf:
          - format: date-time
            type: string
          - type: 'null'
          description: The creation date of the datasource
          title: Created At
        description:
          anyOf:
          - type: string
          - type: 'null'
          description: The description of the datasource
          title: Description
        destinations:
          description: Indexes hydrated from this datasources
          items:
            type: string
          title: Destinations
          type: array
        enabled:
          default: true
          description: Whether the datasource is enabled
          title: Enabled
          type: boolean
        filename_to_attributes:
          additionalProperties:
            type: object
          description: Mapping of filename or regex to attributes
          title: Filename To Attributes
          type: object
        id:
          anyOf:
          - format: uuid4
            type: string
          - type: 'null'
          description: The unique identifier of the datasource
          title: Id
        name:
          description: The name of the datasource
          title: Name
          type: string
        updated_at:
          anyOf:
          - format: date-time
            type: string
          - type: 'null'
          description: The last update date of the datasource
          title: Updated At
      required:
      - name
      - config
      - destinations
      title: DataSource
      type: object
    DirectSearchInput:
      properties:
        query:
          description: The query to be used for the search
          title: Query
          type: object
        scroll:
          anyOf:
          - type: string
          - type: 'null'
          description: Scroll id to be passed for the next set of results
          title: Scroll
        size:
          default: 10
          description: The number of documents to return
          title: Size
          type: integer
      required:
      - query
      title: DirectSearchInput
      type: object
    DirectSearchResponse:
      properties:
        hits:
          items:
            $ref: '#/components/schemas/ScoredDocumentChunkReturn'
          title: Hits
          type: array
        scroll_id:
          anyOf:
          - type: string
          - type: 'null'
          description: Scroll ID for pagination
          title: Scroll Id
      required:
      - hits
      title: DirectSearchResponse
      type: object
    DirectSearchScrollInput:
      properties:
        scroll:
          default: 1m
          description: Period to retain search scroll
          title: Scroll
          type: string
        scroll_id:
          description: Scroll id to be passed for the next set of results
          title: Scroll Id
          type: string
      required:
      - scroll_id
      title: DirectSearchScrollInput
      type: object
    Document-Input:
      properties:
        authorized_groups:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: The groups that are authorized to access the document. This
            is useful when using Document-level Security and RBAC must be enabled
          title: Authorized Groups
        chunks:
          description: "The document\u2019s chunks (e.g. paragraphs, pages, tables,\
            \ images) "
          items:
            $ref: '#/components/schemas/DocumentChunk-Input'
          title: Chunks
          type: array
        content:
          description: Dictionary of document content field, including text, metadata,
            and any user provided filters
          title: Content
          type: object
        document_id:
          description: The unique document_id
          title: Document Id
          type: string
        index_fields:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: "Specifies which fields will be included in the semantic search\
            \ embedded text, defaults to \u201Ctext\u201D and \u201Cmeta\u201D. "
          title: Index Fields
        parent_document_id:
          description: The unique id for the parent document
          title: Parent Document Id
          type: string
        path:
          description: 'The path from which the file came from; if the '
          title: Path
          type: string
      required:
      - document_id
      - path
      - parent_document_id
      - content
      - chunks
      title: Document
      type: object
    Document-Output:
      properties:
        authorized_groups:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: The groups that are authorized to access the document. This
            is useful when using Document-level Security and RBAC must be enabled
          title: Authorized Groups
        chunks:
          description: "The document\u2019s chunks (e.g. paragraphs, pages, tables,\
            \ images) "
          items:
            $ref: '#/components/schemas/DocumentChunk-Output'
          title: Chunks
          type: array
        content:
          description: Dictionary of document content field, including text, metadata,
            and any user provided filters
          title: Content
          type: object
        document_id:
          description: The unique document_id
          title: Document Id
          type: string
        index_fields:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: "Specifies which fields will be included in the semantic search\
            \ embedded text, defaults to \u201Ctext\u201D and \u201Cmeta\u201D. "
          title: Index Fields
        parent_document_id:
          description: The unique id for the parent document
          title: Parent Document Id
          type: string
        path:
          description: 'The path from which the file came from; if the '
          title: Path
          type: string
      required:
      - document_id
      - path
      - parent_document_id
      - content
      - chunks
      title: Document
      type: object
    DocumentChunk-Input:
      properties:
        asset_ids:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: 'This is meant for internal use '
          title: Asset Ids
        assets:
          anyOf:
          - items:
              $ref: '#/components/schemas/DocumentChunkAsset'
            type: array
          - type: 'null'
          description: '[to be deprecated] List of CompassDocumentChunkAsset. The
            length of the assets will depend on the origin file_type as well as the
            parser_config set'
          title: Assets
        assets_info:
          anyOf:
          - items:
              $ref: '#/components/schemas/DocumentChunkAssetInfo'
            type: array
          - type: 'null'
          description: List of AssetInfo objects. The length of the assets will depend
            on the origin file_type as well as the parser_config set
          title: Assets Info
        chunk_id:
          description: The unique id for the specific chunk in the database
          title: Chunk Id
          type: string
        content:
          description: Dict that contains the data to be used for embeddings
          title: Content
          type: object
        origin:
          anyOf:
          - type: object
          - type: 'null'
          description: "Dict that contains data around the origin of the chunk. This\
            \ contents of the origin may depend on the origin file_type but should\
            \ always contain: 1) filename : the name of the parent file the chunk\
            \ came from \nIf the file_type=pdf then it will also have page_number"
          title: Origin
        parent_document_id:
          description: The unique id for the parent document - this allows to group
            chunks by parent_document_id to get all children of a parent document
          title: Parent Document Id
          type: string
        path:
          description: The path from which the parent file came from
          title: Path
          type: string
        sort_id:
          description: '[deprecated] This is the original order of the chunk in respect
            to the parent document'
          title: Sort Id
          type: integer
      required:
      - chunk_id
      - sort_id
      - parent_document_id
      - path
      - content
      title: DocumentChunk
      type: object
    DocumentChunk-Output:
      properties:
        asset_ids:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: 'This is meant for internal use '
          title: Asset Ids
        assets:
          anyOf:
          - items:
              $ref: '#/components/schemas/DocumentChunkAsset'
            type: array
          - type: 'null'
          description: '[to be deprecated] List of CompassDocumentChunkAsset. The
            length of the assets will depend on the origin file_type as well as the
            parser_config set'
          title: Assets
        assets_info:
          anyOf:
          - items:
              $ref: '#/components/schemas/DocumentChunkAssetInfo'
            type: array
          - type: 'null'
          description: List of AssetInfo objects. The length of the assets will depend
            on the origin file_type as well as the parser_config set
          title: Assets Info
        chunk_id:
          description: The unique id for the specific chunk in the database
          title: Chunk Id
          type: string
        content:
          description: Dict that contains the data to be used for embeddings
          title: Content
          type: object
        origin:
          anyOf:
          - type: object
          - type: 'null'
          description: "Dict that contains data around the origin of the chunk. This\
            \ contents of the origin may depend on the origin file_type but should\
            \ always contain: 1) filename : the name of the parent file the chunk\
            \ came from \nIf the file_type=pdf then it will also have page_number"
          title: Origin
        parent_document_id:
          description: The unique id for the parent document - this allows to group
            chunks by parent_document_id to get all children of a parent document
          title: Parent Document Id
          type: string
        path:
          description: The path from which the parent file came from
          title: Path
          type: string
        sort_id:
          description: '[deprecated] This is the original order of the chunk in respect
            to the parent document'
          title: Sort Id
          type: integer
      required:
      - chunk_id
      - sort_id
      - parent_document_id
      - path
      - content
      title: DocumentChunk
      type: object
    DocumentChunkAsset:
      properties:
        asset_data:
          description: The raw data of the asset
          title: Asset Data
          type: string
        asset_type:
          $ref: '#/components/schemas/AssetType'
          description: "String with the possible values: \n1) page_image: a page that\
            \ has been rendered as an image. This will come from PDFs \n2) page_markdown:\
            \  a markdown representation of a page\u2019s content. This will come\
            \ from PDFs when the parsing config is set as ImageToMarkdown \n3) document_text:\
            \ a dump of text extracted extracted from a document"
        content_type:
          description: 'The content type of the asset: image/jpeg, text/markdown'
          title: Content Type
          type: string
      required:
      - asset_type
      - content_type
      - asset_data
      title: DocumentChunkAsset
      type: object
    DocumentChunkAssetInfo:
      properties:
        asset_id:
          description: The unique id for the asset
          title: Asset Id
          type: string
        asset_type:
          $ref: '#/components/schemas/AssetType'
          description: 'The type of asset in the asset_info dictionary, describes
            contents of the associated presigned url '
        content_type:
          description: 'Mime-type of base file '
          title: Content Type
          type: string
        presigned_url:
          description: 'Presigned url fetchable with a 1hr time-to-live '
          title: Presigned Url
          type: string
      required:
      - asset_id
      - asset_type
      - content_type
      - presigned_url
      title: DocumentChunkAssetInfo
      type: object
    DocumentResponse:
      properties:
        document:
          $ref: '#/components/schemas/Document-Output'
      required:
      - document
      title: DocumentResponse
      type: object
    DocumentStatus:
      properties:
        created_at:
          description: First time the document was created
          format: date-time
          title: Created At
          type: string
        destinations:
          description: Destination indexes
          items:
            type: string
          title: Destinations
          type: array
        document_id:
          description: Internal id of the document
          title: Document Id
          type: string
        source_id:
          anyOf:
          - type: string
          - type: 'null'
          description: Internal identifier for source
          title: Source Id
        state:
          description: Last known state of the document
          title: State
          type: string
        updated_at:
          anyOf:
          - format: date-time
            type: string
          - type: 'null'
          description: Last time the document was updated
          title: Updated At
      required:
      - document_id
      - state
      - destinations
      - created_at
      title: DocumentStatus
      type: object
    FilterType:
      enum:
      - $eq
      - $neq
      - $lte
      - $gte
      - $wordMatch
      title: FilterType
      type: string
    GetConfigResponse:
      properties:
        auth_url:
          anyOf:
          - type: string
          - type: 'null'
          description: The URL to redirect to for authentication
          title: Auth Url
        config_schema:
          description: The configuration schema for the datasource
          title: Config Schema
      required:
      - config_schema
      title: GetConfigResponse
      type: object
    GroupAuthorizationAction:
      enum:
      - add
      - remove
      title: GroupAuthorizationAction
      type: string
    GroupAuthorizationInput:
      properties:
        action:
          $ref: '#/components/schemas/GroupAuthorizationAction'
          description: Action to perform on the document
        authorized_groups:
          description: List of RBAC groups the documents should be authorized for
          items:
            type: string
          title: Authorized Groups
          type: array
        document_ids:
          description: List of document ids to update
          items:
            type: string
          title: Document Ids
          type: array
      required:
      - document_ids
      - authorized_groups
      - action
      title: GroupAuthorizationInput
      type: object
    HTTPValidationError:
      properties:
        detail:
          items:
            $ref: '#/components/schemas/ValidationError'
          title: Detail
          type: array
      title: HTTPValidationError
      type: object
    IndexConfigInput:
      properties:
        analyzer:
          default: english
          description: Analyzer is a parameter set for multimodality. For all EAPs,
            the default value should be used (english)
          title: Analyzer
          type: string
        number_of_replicas:
          anyOf:
          - type: integer
          - type: 'null'
          description: Number of replicas for the index.
          title: Number Of Replicas
        number_of_shards:
          default: 3
          description: Number of shards is used for indexes by customers that are
            very large (>10MM chunks). For all EAPs, the default of 3 should suffice
            unless Cohere has set up the index for you
          title: Number Of Shards
          type: integer
      title: IndexConfigInput
      type: object
    IndexInfo:
      properties:
        count:
          description: The total number of chunks in the index
          title: Count
          type: integer
        name:
          description: 'The name of the index - this has to be unique '
          title: Name
          type: string
        parent_doc_count:
          anyOf:
          - type: integer
          - type: 'null'
          description: The total number of files provided for the index - files can
            be broken into 1..* chunks
          title: Parent Doc Count
      required:
      - name
      - count
      - parent_doc_count
      title: IndexInfo
      type: object
    ListIndexesResponse:
      properties:
        indexes:
          items:
            $ref: '#/components/schemas/IndexInfo'
          title: Indexes
          type: array
      required:
      - indexes
      title: ListIndexesResponse
      type: object
    OneDriveConfig:
      properties:
        type:
          const: msft_onedrive
          title: Type
          type: string
      required:
      - type
      title: OneDriveConfig
      type: object
    PaginatedList_DataSource_:
      properties:
        limit:
          anyOf:
          - type: integer
          - type: 'null'
          default: 100
          title: Limit
        skip:
          anyOf:
          - type: integer
          - type: 'null'
          default: 0
          title: Skip
        value:
          items:
            $ref: '#/components/schemas/DataSource'
          title: Value
          type: array
      required:
      - value
      title: PaginatedList[DataSource]
      type: object
    PaginatedList_DocumentStatus_:
      properties:
        limit:
          anyOf:
          - type: integer
          - type: 'null'
          default: 100
          title: Limit
        skip:
          anyOf:
          - type: integer
          - type: 'null'
          default: 0
          title: Skip
        value:
          items:
            $ref: '#/components/schemas/DocumentStatus'
          title: Value
          type: array
      required:
      - value
      title: PaginatedList[DocumentStatus]
      type: object
    PutDocumentResult:
      properties:
        document_id:
          description: The document id passed in the request
          title: Document Id
          type: string
        error:
          anyOf:
          - type: string
          - type: 'null'
          description: Errors if any
          title: Error
        task_ids:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: Internal background task ids
          title: Task Ids
      required:
      - document_id
      - error
      title: PutDocumentResult
      type: object
    PutDocumentsInput:
      properties:
        authorized_groups:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: The groups that are authorized to access the document. This
            is useful when using Document-level Security and RBAC must be enabled
          title: Authorized Groups
        documents:
          items:
            $ref: '#/components/schemas/Document-Input'
          title: Documents
          type: array
        merge_groups_on_conflict:
          anyOf:
          - type: boolean
          - type: 'null'
          default: false
          description: When Document-level Security is enabled, allows upserting documents
            with static groups
          title: Merge Groups On Conflict
      required:
      - documents
      title: PutDocumentsInput
      type: object
    PutDocumentsResponse:
      properties:
        results:
          items:
            $ref: '#/components/schemas/PutDocumentResult'
          title: Results
          type: array
      required:
      - results
      title: PutDocumentsResponse
      type: object
    ScoredDocument:
      properties:
        authorized_groups:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: The groups that are authorized to access the document. This
            is useful when using Document-level Security and RBAC must be enabled
          title: Authorized Groups
        chunks:
          items:
            $ref: '#/components/schemas/ScoredDocumentChunk'
          title: Chunks
          type: array
        content:
          description: Dictionary of document content field, including text, metadata,
            and any user provided filters
          title: Content
          type: object
        document_id:
          description: The unique document_id
          title: Document Id
          type: string
        index_fields:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: "Specifies which fields will be included in the semantic search\
            \ embedded text, defaults to \u201Ctext\u201D and \u201Cmeta\u201D. "
          title: Index Fields
        parent_document_id:
          description: The unique id for the parent document
          title: Parent Document Id
          type: string
        path:
          description: 'The path from which the file came from; if the '
          title: Path
          type: string
        score:
          description: A relevancy score of the document. Search Document scores are
            not guaranteed to be between 0 and 1.
          title: Score
          type: number
      required:
      - document_id
      - path
      - parent_document_id
      - content
      - chunks
      - score
      title: ScoredDocument
      type: object
    ScoredDocumentChunk:
      properties:
        asset_ids:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: 'This is meant for internal use '
          title: Asset Ids
        assets:
          anyOf:
          - items:
              $ref: '#/components/schemas/DocumentChunkAsset'
            type: array
          - type: 'null'
          description: '[to be deprecated] List of CompassDocumentChunkAsset. The
            length of the assets will depend on the origin file_type as well as the
            parser_config set'
          title: Assets
        assets_info:
          anyOf:
          - items:
              $ref: '#/components/schemas/DocumentChunkAssetInfo'
            type: array
          - type: 'null'
          description: List of AssetInfo objects. The length of the assets will depend
            on the origin file_type as well as the parser_config set
          title: Assets Info
        chunk_id:
          description: The unique id for the specific chunk in the database
          title: Chunk Id
          type: string
        content:
          description: Dict that contains the data to be used for embeddings
          title: Content
          type: object
        origin:
          anyOf:
          - type: object
          - type: 'null'
          description: "Dict that contains data around the origin of the chunk. This\
            \ contents of the origin may depend on the origin file_type but should\
            \ always contain: 1) filename : the name of the parent file the chunk\
            \ came from \nIf the file_type=pdf then it will also have page_number"
          title: Origin
        parent_document_id:
          description: The unique id for the parent document - this allows to group
            chunks by parent_document_id to get all children of a parent document
          title: Parent Document Id
          type: string
        path:
          description: The path from which the parent file came from
          title: Path
          type: string
        score:
          description: Relevancy score of the chunk normalized between [0,1]. Normalization
            of chunk scores do not depend on the set of chunks retrieved
          title: Score
          type: number
        sort_id:
          description: '[deprecated] This is the original order of the chunk in respect
            to the parent document'
          title: Sort Id
          type: integer
      required:
      - chunk_id
      - sort_id
      - parent_document_id
      - path
      - content
      - score
      title: ScoredDocumentChunk
      type: object
    ScoredDocumentChunkReturn:
      properties:
        asset_ids:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: 'This is meant for internal use '
          title: Asset Ids
        assets:
          anyOf:
          - items:
              $ref: '#/components/schemas/DocumentChunkAsset'
            type: array
          - type: 'null'
          description: '[to be deprecated] List of CompassDocumentChunkAsset. The
            length of the assets will depend on the origin file_type as well as the
            parser_config set'
          title: Assets
        assets_info:
          anyOf:
          - items:
              $ref: '#/components/schemas/DocumentChunkAssetInfo'
            type: array
          - type: 'null'
          description: List of AssetInfo objects. The length of the assets will depend
            on the origin file_type as well as the parser_config set
          title: Assets Info
        chunk_id:
          description: The unique id for the specific chunk in the database
          title: Chunk Id
          type: string
        content:
          description: Dict that contains the data to be used for embeddings
          title: Content
          type: object
        document_id:
          description: The unique id for the document
          title: Document Id
          type: string
        index_fields:
          anyOf:
          - items:
              type: string
            type: array
          - type: 'null'
          description: The fields that are indexed
          title: Index Fields
        origin:
          anyOf:
          - type: object
          - type: 'null'
          description: "Dict that contains data around the origin of the chunk. This\
            \ contents of the origin may depend on the origin file_type but should\
            \ always contain: 1) filename : the name of the parent file the chunk\
            \ came from \nIf the file_type=pdf then it will also have page_number"
          title: Origin
        parent_document_id:
          description: The unique id for the parent document - this allows to group
            chunks by parent_document_id to get all children of a parent document
          title: Parent Document Id
          type: string
        path:
          description: The path of the document
          title: Path
          type: string
        score:
          description: Relevancy score of the chunk normalized between [0,1]. Normalization
            of chunk scores do not depend on the set of chunks retrieved
          title: Score
          type: number
        sort_id:
          description: '[deprecated] This is the original order of the chunk in respect
            to the parent document'
          title: Sort Id
          type: integer
      required:
      - chunk_id
      - sort_id
      - parent_document_id
      - path
      - content
      - score
      - document_id
      title: ScoredDocumentChunkReturn
      type: object
    SearchChunksResponse:
      properties:
        hits:
          items:
            $ref: '#/components/schemas/ScoredDocumentChunkReturn'
          title: Hits
          type: array
      required:
      - hits
      title: SearchChunksResponse
      type: object
    SearchDocumentsResponse:
      properties:
        hits:
          description: List of documents returned by the search query
          items:
            $ref: '#/components/schemas/ScoredDocument'
          title: Hits
          type: array
      required:
      - hits
      title: SearchDocumentsResponse
      type: object
    SearchFilter:
      properties:
        field:
          description: The field on the index-level to be used for filtering
          title: Field
          type: string
        type:
          $ref: '#/components/schemas/FilterType'
          description: "Different operations that can be used to filter the specified\
            \ field: \n1) $eq will be a term match2) $gte and $lte will become range\
            \ queries3) $wordMatch will be converted to a string"
        value:
          description: 'The value the filter should use '
          title: Value
      required:
      - field
      - type
      - value
      title: SearchFilter
      type: object
    SearchInput:
      properties:
        enable_profiling:
          default: false
          description: This includes some performance data around the search response
            - helpful for debugging otherwise it will slow the response time of the
            query
          title: Enable Profiling
          type: boolean
        filters:
          anyOf:
          - items:
              $ref: '#/components/schemas/SearchFilter'
            type: array
          - type: 'null'
          description: A list of filters which will be applied onto the search
          title: Filters
        query:
          description: The query to be searched into the index
          minLength: 1
          title: Query
          type: string
        top_k:
          description: 'The number of documents to be returned '
          title: Top K
          type: integer
      required:
      - query
      - top_k
      title: SearchInput
      type: object
    UploadDocumentsRequest:
      properties:
        documents:
          description: A list of documents to be inserted
          items:
            $ref: '#/components/schemas/UploadDocumentsRequestDocument'
          maxItems: 100
          minItems: 1
          title: Documents
          type: array
      required:
      - documents
      title: UploadDocumentsRequest
      type: object
    UploadDocumentsRequestDocument:
      properties:
        attributes:
          anyOf:
          - type: object
          - type: 'null'
          description: 'Additional context to be embedded with the document '
          title: Attributes
        content_encoded_bytes:
          description: The content encoded as bytes
          title: Content Encoded Bytes
          type: string
        content_length_bytes:
          description: The bytes of the document
          exclusiveMinimum: 0.0
          title: Content Length Bytes
          type: integer
        content_type:
          $ref: '#/components/schemas/ContentTypeEnum'
          description: The content type of the document
        filename:
          description: The filename of the document
          minLength: 1
          title: Filename
          type: string
        id:
          description: The unique id for the document
          title: Id
          type: string
      required:
      - id
      - filename
      - content_type
      - content_length_bytes
      - content_encoded_bytes
      title: UploadDocumentsRequestDocument
      type: object
    UploadDocumentsResponse:
      properties:
        document_ids:
          description: The unique ids for the documents
          items:
            type: string
          title: Document Ids
          type: array
        upload_id:
          description: The unique id for the upload
          format: uuid4
          title: Upload Id
          type: string
      required:
      - upload_id
      - document_ids
      title: UploadDocumentsResponse
      type: object
    ValidationError:
      properties:
        loc:
          items:
            anyOf:
            - type: string
            - type: integer
          title: Location
          type: array
        msg:
          title: Message
          type: string
        type:
          title: Error Type
          type: string
      required:
      - loc
      - msg
      - type
      title: ValidationError
      type: object
info:
  title: Compass search API
  version: 0.1.0
openapi: 3.1.0
paths:
  /metrics:
    get:
      description: Endpoint that serves Prometheus metrics.
      operationId: metrics_metrics_get
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
      summary: Metrics
  /v1/datasources/:
    get:
      description: List all datasources created by a user
      operationId: list_datasources_v1_datasources__get
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaginatedList_DataSource_'
          description: Successful Response
      summary: List all datasources
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\nfrom cohere_compass.models\
          \ import PaginatedList\n\nCOMPASS_API_URL = ...\nBEARER_TOKEN = ...\n\n\
          compass_client = CompassClient(\n    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n\
          )\nr = compass_client.list_datasources()\n\nif isinstance(r, str):\n   \
          \ raise Exception(f\"Failed to list datasources: {r}\")\n\nif isinstance(r,\
          \ PaginatedList):\n    datasources = r.value\n    for datasource in datasources:\n\
          \        print(f\"Datasource id: {datasource.id}\")\n        print(f\"Datasource\
          \ name: {datasource.name}\")\n        print(f\"Datasource description: {datasource.description}\"\
          )\n        print(f\"Datasource enabled: {datasource.enabled}\")\n"
    post:
      description: Create a new datasource
      operationId: create_datasource_v1_datasources__post
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateDataSource'
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DataSource'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Create a datasource
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\nfrom cohere_compass.models\
          \ import AzureBlobStorageConfig, CreateDataSource, DataSource\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\n\nDATASOURCE_ENABLED: bool\
          \ = ...\nDATASOURCE_NAME = ...\nDATASOURCE_DESCRIPTION = ...\n\nAZURE_BLOB_STORAGE_CONNECTION_STRING\
          \ = ...\nAZURE_BLOB_STORAGE_CONTAINER_NAME = ...\nAZURE_BLOB_STORAGE_NAME_STARTS_WITH\
          \ = ...\n\ncompass_client = CompassClient(\n    index_url=COMPASS_API_URL,\n\
          \    bearer_token=BEARER_TOKEN,\n)\n\ncompass_client.create_index(index_name=INDEX_NAME)\n\
          \ndatasource = compass_client.create_datasource(\n    datasource=CreateDataSource(\n\
          \        datasource=DataSource(\n            name=DATASOURCE_NAME,\n   \
          \         description=DATASOURCE_DESCRIPTION,\n            config=AzureBlobStorageConfig(\n\
          \                type=\"msft_azure_blob_storage\",\n                connection_string=AZURE_BLOB_STORAGE_CONNECTION_STRING,\n\
          \                container_name=AZURE_BLOB_STORAGE_CONTAINER_NAME,\n   \
          \             name_starts_with=AZURE_BLOB_STORAGE_NAME_STARTS_WITH,\n  \
          \          ),\n            destinations=[INDEX_NAME],\n            enabled=DATASOURCE_ENABLED,\n\
          \        )\n    )\n)\n\nif isinstance(datasource, str):\n    raise Exception(f\"\
          Failed to create datasources: {datasource}\")\n\nif isinstance(datasource,\
          \ DataSource):\n    print(datasource)\n"
  /v1/datasources/config:
    get:
      description: List all available config types for datasources
      operationId: list_configs_v1_datasources_config_get
      responses:
        '200':
          content:
            application/json:
              schema:
                items:
                  type: string
                title: Response List Configs V1 Datasources Config Get
                type: array
          description: Successful Response
      summary: Available config types for datasourecs
  /v1/datasources/config/{config_type}:
    get:
      description: Get the configuration schema for a datasource
      operationId: get_config_v1_datasources_config__config_type__get
      parameters:
      - description: Config type returned from GET /config
        in: path
        name: config_type
        required: true
        schema:
          description: Config type returned from GET /config
          title: Config Type
          type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetConfigResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Get datasource config
  /v1/datasources/{datasource_id}:
    delete:
      description: Delete a specified data source
      operationId: delete_datasource_v1_datasources__datasource_id__delete
      parameters:
      - description: Datasource uuid
        in: path
        name: datasource_id
        required: true
        schema:
          description: Datasource uuid
          format: uuid
          title: Datasource Id
          type: string
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Delete a datasource
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\n\nDATASOURCE_ID = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\nr\
          \ = compass_client.delete_datasource(datasource_id=DATASOURCE_ID)\n\nprint(r)\n"
    get:
      description: Retrieve the specific details around a datasource
      operationId: get_datasource_v1_datasources__datasource_id__get
      parameters:
      - description: Datasource uuid
        in: path
        name: datasource_id
        required: true
        schema:
          description: Datasource uuid
          format: uuid
          title: Datasource Id
          type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DataSource'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Get a datasource
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\n\nDATASOURCE_ID = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\nr\
          \ = compass_client.get_datasource(datasource_id=DATASOURCE_ID)\n\nprint(r)\n"
  /v1/datasources/{datasource_id}/_sync:
    post:
      description: Triggers the immediate syncing of a specified datasource
      operationId: sync_datasource_v1_datasources__datasource_id___sync_post
      parameters:
      - description: Datasource uuid
        in: path
        name: datasource_id
        required: true
        schema:
          description: Datasource uuid
          format: uuid
          title: Datasource Id
          type: string
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Sync a datasource
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\n\nDATASOURCE_ID = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\nr =\
          \ compass_client.sync_datasource(\n    datasource_id=DATASOURCE_ID,\n)\n\
          \nprint(r)\n"
  /v1/datasources/{datasource_id}/documents/:
    get:
      description: List all document status for a given datasource
      operationId: list_datasources_objects_states_v1_datasources__datasource_id__documents__get
      parameters:
      - description: Datasource uuid
        in: path
        name: datasource_id
        required: true
        schema:
          description: Datasource uuid
          format: uuid
          title: Datasource Id
          type: string
      - description: Skip the first N documents, used for pagination
        in: query
        name: skip
        required: true
        schema:
          anyOf:
          - minimum: 0
            type: integer
          - type: 'null'
          description: Skip the first N documents, used for pagination
          title: Skip
      - description: Limit the number of documents returned, used for pagination
        in: query
        name: limit
        required: true
        schema:
          anyOf:
          - maximum: 100
            minimum: 0
            type: integer
          - type: 'null'
          description: Limit the number of documents returned, used for pagination
          title: Limit
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PaginatedList_DocumentStatus_'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Document status for a datasource
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\nfrom cohere_compass.models\
          \ import PaginatedList\n\nCOMPASS_API_URL = ...\nBEARER_TOKEN = ...\n\n\
          DATASOURCE_ID = ...\n\ncompass_client = CompassClient(\n    index_url=COMPASS_API_URL,\n\
          \    bearer_token=BEARER_TOKEN,\n)\nr = compass_client.list_datasources_objects_states(\n\
          \    datasource_id=DATASOURCE_ID,\n)\n\nif isinstance(r, str):\n    raise\
          \ Exception(f\"Failed to list datasources: {r}\")\n\nif isinstance(r, PaginatedList):\n\
          \    documents = r.value\n    for document in documents:\n        print(f\"\
          Document id: {document.document_id}\")\n        print(f\"Document state:\
          \ {document.state}\")\n        print(f\"Document source id: {document.source_id}\"\
          )\n        print(f\"Document destination: {document.destinations}\")\n"
  /v1/indexes/:
    get:
      description: Returns a list of all indexes. If RBAC is enabled only indices
        which the user has READ or WRITE permission are returned.
      operationId: list_indexes_v1_indexes__get
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListIndexesResponse'
          description: Successful Response
      summary: List all indexes
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\nr\
          \ = compass_client.list_indexes()\nif r.error:\n    raise Exception(f\"\
          Failed to list indexes: {r.error}\")\n\nindexes = r.result[\"indexes\"]\n\
          for index in indexes:\n    print(f\"Index name: {index['name']}\")\n   \
          \ print(f\"Chunk count: {index['count']}\")\n    print(f\"Document count:\
          \ {index['parent_doc_count']}\")\n"
  /v1/indexes/_direct_search/scroll:
    post:
      description: Direct search with scroll. This endpoint allows users to paginate
        through the search results.
      operationId: direct_search_scroll_v1_indexes__direct_search_scroll_post
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DirectSearchScrollInput'
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DirectSearchResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Direct search with scroll
      x-codeSamples:
      - lang: python
        source: "from typing import Optional\n\nfrom cohere_compass.clients import\
          \ CompassClient\nfrom cohere_compass.models import RetrievedChunkExtended\n\
          \nCOMPASS_API_URL = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\nDOCUMENT_ID\
          \ = ...\n\ncompass_client = CompassClient(\n    index_url=COMPASS_API_URL,\n\
          \    bearer_token=BEARER_TOKEN,\n)\n\nquery = {\"query\": {\"match_all\"\
          : {}}}\n\n\ndef call_direct_search_scroll(\n    hits: list[RetrievedChunkExtended],\n\
          \    scroll_id: Optional[str] = None,\n) -> list[RetrievedChunkExtended]:\n\
          \    if hits is None:\n        hits = []\n\n    if scroll_id is None:\n\
          \        return hits\n\n    results_scroll = compass_client.direct_search_scroll(\n\
          \        scroll_id=scroll_id,\n        scroll=\"1m\",\n    )\n\n    hits.extend(results_scroll.hits)\n\
          \    return call_direct_search_scroll(hits=hits, scroll_id=results.scroll_id)\n\
          \n\nresults = compass_client.direct_search(\n    index_name=INDEX_NAME,\n\
          \    query=query,\n    scroll=\"1m\",\n    size=100,\n)\n\nhits = call_direct_search_scroll(hits=results.hits,\
          \ scroll_id=results.scroll_id)\n"
  /v1/indexes/{index_name}:
    delete:
      description: Deletes the specified index. If RBAC is enabled only indices which
        the user has WRITE permission are able to be deleted.
      operationId: delete_index_v1_indexes__index_name__delete
      parameters:
      - description: The name of the index to be deleted
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index to be deleted
          title: Index Name
          type: string
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Delete an index
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\nr\
          \ = compass_client.delete_index(index_name=INDEX_NAME)\n\nif r.error:\n\
          \    raise Exception(f\"Failed to delete index: {r.error}\")\n"
    put:
      description: Creates a new index with the specified name. If the index already
        exists returns status code 200.
      operationId: create_index_v1_indexes__index_name__put
      parameters:
      - description: 'The name of the index to be created - this has to be unique '
        in: path
        name: index_name
        required: true
        schema:
          description: 'The name of the index to be created - this has to be unique '
          title: Index Name
          type: string
      requestBody:
        content:
          application/json:
            schema:
              anyOf:
              - $ref: '#/components/schemas/IndexConfigInput'
              - type: 'null'
              title: Index Config
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Create an index
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\nr\
          \ = compass_client.create_index(index_name=INDEX_NAME)\n\nif r.error:\n\
          \    raise Exception(f\"Failed to create index: {r.error}\")\n"
  /v1/indexes/{index_name}/_direct_search:
    post:
      description: Direct search into the index. This endpoint allows users to search
        directly into the index without any processing.
      operationId: direct_search_v1_indexes__index_name___direct_search_post
      parameters:
      - description: The name of the index to be searched
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index to be searched
          title: Index Name
          type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DirectSearchInput'
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DirectSearchResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Direct search into the index
      x-codeSamples:
      - lang: python
        source: "from typing import Optional\n\nfrom cohere_compass.clients import\
          \ CompassClient\nfrom cohere_compass.models import RetrievedChunkExtended\n\
          \nCOMPASS_API_URL = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\nDOCUMENT_ID\
          \ = ...\n\ncompass_client = CompassClient(\n    index_url=COMPASS_API_URL,\n\
          \    bearer_token=BEARER_TOKEN,\n)\n\nquery = {\"query\": {\"match_all\"\
          : {}}}\n\n\ndef call_direct_search_scroll(\n    hits: list[RetrievedChunkExtended],\n\
          \    scroll_id: Optional[str] = None,\n) -> list[RetrievedChunkExtended]:\n\
          \    if hits is None:\n        hits = []\n\n    if scroll_id is None:\n\
          \        return hits\n\n    results_scroll = compass_client.direct_search_scroll(\n\
          \        scroll_id=scroll_id,\n        scroll=\"1m\",\n    )\n\n    hits.extend(results_scroll.hits)\n\
          \    return call_direct_search_scroll(hits=hits, scroll_id=results.scroll_id)\n\
          \n\nresults = compass_client.direct_search(\n    index_name=INDEX_NAME,\n\
          \    query=query,\n    scroll=\"1m\",\n    size=100,\n)\n\nhits = call_direct_search_scroll(hits=results.hits,\
          \ scroll_id=results.scroll_id)\n"
  /v1/indexes/{index_name}/_flush:
    post:
      description: Flushes the documents  in memory for a given index to disk. This
        is an intensive task and should be used sparingly, for example, for manual
        restarts or to free up memory.
      operationId: flush_index_v1_indexes__index_name___flush_post
      parameters:
      - description: The name of the index to be flushed
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index to be flushed
          title: Index Name
          type: string
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Flush an index
  /v1/indexes/{index_name}/_refresh:
    post:
      description: Pushes newly inserted document to be made available for search
        immediately.
      operationId: refresh_index_v1_indexes__index_name___refresh_post
      parameters:
      - description: The name of the index to be refreshed
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index to be refreshed
          title: Index Name
          type: string
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Refresh an index
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\nr\
          \ = compass_client.refresh_index(index_name=INDEX_NAME)\nif r.error:\n \
          \   raise Exception(f\"Failed to refresh indexes: {r.error}\")\n"
  /v1/indexes/{index_name}/documents:
    put:
      description: This endpoint allows users to update or insert documents into a
        specified index. By providing a PutDocumentsInput object, users can define
        the documents to be added or modified. The PUT method is used to perform the
        operation, ensuring that the documents are either updated or inserted into
        the index. If RBAC is enabled, the user will need to be in a group with a
        role that has WRITE permissions on the index.
      operationId: put_documents_v1_indexes__index_name__documents_put
      parameters:
      - description: The name of the index for documents to be inserted into
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index for documents to be inserted into
          title: Index Name
          type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PutDocumentsInput'
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PutDocumentsResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Put documents into an index
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient, CompassParserClient\n\
          \nCOMPASS_API_URL = ...\nPARSER_URL = ...\nBEARER_TOKEN = ...\nINDEX_NAME\
          \ = ...\nFOLDER_TO_PROCESS = ...\n\ncompass_client = CompassClient(\n  \
          \  index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\ncompass_parser_client\
          \ = CompassParserClient(parser_url=PARSER_URL)\n\ndocs_to_index = compass_parser_client.process_folder(\n\
          \    folder_path=FOLDER_TO_PROCESS, recursive=True\n)\n\ncompass_client.create_index(index_name=INDEX_NAME)\n\
          r = compass_client.insert_docs(index_name=INDEX_NAME, docs=docs_to_index,\
          \ num_jobs=1)\n\nprint(r)\n"
  /v1/indexes/{index_name}/documents/_search:
    post:
      description: Perform a search query on the specified index and return a list
        of relevant documents along with their scores. This returns a list of Document
        objects, which contain all chunks from an indexed document. If RBAC is enabled
        the user  will need to belong to a group with role that has READ permission
        on the index.
      operationId: search_documents_v1_indexes__index_name__documents__search_post
      parameters:
      - description: The name of the index to be searched
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index to be searched
          title: Index Name
          type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/SearchInput'
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SearchDocumentsResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Search Documents within an Index
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\nDOCUMENT_ID = ...\nSEARCH_QUERY\
          \ = ...\n\ncompass_client = CompassClient(\n    index_url=COMPASS_API_URL,\n\
          \    bearer_token=BEARER_TOKEN,\n)\n\nr = compass_client.search_documents(index_name=INDEX_NAME,\
          \ query=SEARCH_QUERY)\n\nif r.error:\n    raise Exception(f\"Failed to search\
          \ doc: {r.error}\")\n\nprint(r.hits)\n"
  /v1/indexes/{index_name}/documents/_search_chunks:
    post:
      description: Search for relevant chunks for a query from documents in a given
        index. If the Compass Parser was used, the granularity returned can depend
        on the document type.  If RBAC is enabled the user will need to be in a group
        with a role that has READ permission on the index.
      operationId: search_chunks_v1_indexes__index_name__documents__search_chunks_post
      parameters:
      - description: The name of the index to be searched
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index to be searched
          title: Index Name
          type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/SearchInput'
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SearchChunksResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Search Chunks within an Index
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\nDOCUMENT_ID = ...\nSEARCH_QUERY\
          \ = ...\n\ncompass_client = CompassClient(\n    index_url=COMPASS_API_URL,\n\
          \    bearer_token=BEARER_TOKEN,\n)\n\nr = compass_client.search_chunks(index_name=INDEX_NAME,\
          \ query=SEARCH_QUERY)\n\nif r.error:\n    raise Exception(f\"Failed to search:\
          \ {r.error}\")\n\nprint(r.hits)\n"
  /v1/indexes/{index_name}/documents/_upload:
    post:
      description: Push a list of documents for processing. The documents will be
        processed asynchronously and will be available for search after processing
        is complete.
      operationId: upload_documents_v1_indexes__index_name__documents__upload_post
      parameters:
      - description: The name of the index for documents to be inserted into
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index for documents to be inserted into
          title: Index Name
          type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UploadDocumentsRequest'
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UploadDocumentsResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Async Insertion of Documents into an Index
      x-codeSamples:
      - lang: python
        source: "import uuid\n\nfrom cohere_compass.clients import CompassClient\n\
          from cohere_compass.models import DocumentAttributes\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\nDOCUMENT_ID = ...\nFILE_PATH\
          \ = ...\nFILE_NAME = ...\nCONTENT_TYPE = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\ndoc_attr\
          \ = DocumentAttributes()\ndoc_attr.key = \"value\"\n\nfile_path = FILE_PATH\n\
          if not file_path:\n    raise Exception(\"FILE_PATH is required\")\n\nwith\
          \ open(file_path, \"rb\") as f:\n    file_bytes = f.read()\n\nresult = compass_client.upload_document(\n\
          \    index_name=INDEX_NAME,\n    filename=FILE_NAME,\n    filebytes=file_bytes,\n\
          \    content_type=CONTENT_TYPE,\n    document_id=uuid.uuid4(),\n)\n\nprint(result)\n"
  /v1/indexes/{index_name}/documents/{document_id}:
    delete:
      description: Delete a single document based on document_id from a particular
        index. If RBAC is enabled the user will need to be in a group with WRITE permission
        on the index.
      operationId: delete_document_v1_indexes__index_name__documents__document_id__delete
      parameters:
      - description: The name of the index where the document should reside
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index where the document should reside
          title: Index Name
          type: string
      - description: The id of the document to be deleted
        in: path
        name: document_id
        required: true
        schema:
          description: The id of the document to be deleted
          title: Document Id
          type: string
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Delete a document
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\nDOCUMENT_ID = ...\n\ncompass_client\
          \ = CompassClient(\n    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n\
          )\n\nr = compass_client.delete_document(index_name=INDEX_NAME, document_id=DOCUMENT_ID)\n\
          \nif r.error:\n    raise Exception(f\"Failed to delete doc: {r.error}\"\
          )\n"
    get:
      description: Returns a single document based on document_id from a particular
        index. If RBAC is enabled the user will need to be in a group with READ permission
        on the index.
      operationId: get_document_v1_indexes__index_name__documents__document_id__get
      parameters:
      - description: The name of the index where the document should reside
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index where the document should reside
          title: Index Name
          type: string
      - description: The parent_document_id of the document to be retrieved
        in: path
        name: document_id
        required: true
        schema:
          description: The parent_document_id of the document to be retrieved
          title: Document Id
          type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DocumentResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Get a Specific Document from an Index
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\n\nCOMPASS_API_URL\
          \ = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\nDOCUMENT_ID = ...\n\ncompass_client\
          \ = CompassClient(\n    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n\
          )\n\nr = compass_client.get_document(index_name=INDEX_NAME, document_id=DOCUMENT_ID)\n\
          \nif r.error:\n    raise Exception(f\"Failed to get doc: {r.error}\")\n\n\
          print(r.result.hits)\n"
  /v1/indexes/{index_name}/documents/{document_id}/_add_attributes:
    post:
      description: Allows you to add attribues to the document for an index. The attributes
        are added to a particular document based on the document_id. If RBAC is enabled
        you will need WRITE permission on the index.
      operationId: add_attributes_v1_indexes__index_name__documents__document_id___add_attributes_post
      parameters:
      - description: The name of the index where the document should reside
        in: path
        name: index_name
        required: true
        schema:
          description: The name of the index where the document should reside
          title: Index Name
          type: string
      - description: The document_id of the document to be updated
        in: path
        name: document_id
        required: true
        schema:
          description: The document_id of the document to be updated
          title: Document Id
          type: string
      requestBody:
        content:
          application/json:
            schema:
              description: The attributes to be added to the document
              title: Attributes
              type: object
        required: true
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Add attributes using doc_id
      x-codeSamples:
      - lang: python
        source: "from cohere_compass.clients import CompassClient\nfrom cohere_compass.models\
          \ import DocumentAttributes\n\nCOMPASS_API_URL = ...\nBEARER_TOKEN = ...\n\
          INDEX_NAME = ...\nDOCUMENT_ID = ...\n\ncompass_client = CompassClient(\n\
          \    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n)\n\ndoc_attr\
          \ = DocumentAttributes()\ndoc_attr.key = \"value\"\n\nerror = compass_client.add_attributes(\n\
          \    index_name=INDEX_NAME,\n    document_id=DOCUMENT_ID,\n    attributes=doc_attr,\n\
          )\n\nif error:\n    raise Exception(f\"Failed to add attributes: {error}\"\
          )\n"
  /v1/indexes/{index_name}/documents/{document_id}/assets/{asset_id}:
    get:
      description: Returns the asset associated with the asset id inside the document.
      operationId: get_document_asset_v1_indexes__index_name__documents__document_id__assets__asset_id__get
      parameters:
      - in: path
        name: index_name
        required: true
        schema:
          title: Index Name
          type: string
      - in: path
        name: document_id
        required: true
        schema:
          title: Document Id
          type: string
      - in: path
        name: asset_id
        required: true
        schema:
          title: Asset Id
          type: string
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Get an Asset from a Document
      x-codeSamples:
      - lang: python
        source: "import json\n\nfrom cohere_compass.clients import CompassClient\n\
          \nCOMPASS_API_URL = ...\nBEARER_TOKEN = ...\nINDEX_NAME = ...\nDOCUMENT_ID\
          \ = ...\nSEARCH_QUERY = ...\n\ncompass_client = CompassClient(\n    index_url=COMPASS_API_URL,\n\
          \    bearer_token=BEARER_TOKEN,\n)\n\nresults = compass_client.search_chunks(index_name=INDEX_NAME,\
          \ query=SEARCH_QUERY)\nif results.error:\n    raise Exception(f\"Failed\
          \ to search chunks: {results.error}\")\n\nhits = results.hits\n\nif not\
          \ hits:\n    raise Exception(\"No hits found\")\n\nhit = hits[0]\n\nasset_id:\
          \ str = hit.assets_info[0].asset_id  # type: ignore\ndocument_id = hit.document_id\n\
          # URL to fetch asset\npresigned_url = hit.assets_info[0].presigned_url\n\
          \n### Get document asset again, after pre-signed url has expired\nasset,\
          \ content_type = compass_client.get_document_asset(\n    index_name=document_id,\n\
          \    document_id=DOCUMENT_ID,\n    asset_id=asset_id,\n)\n\n# Save the asset\
          \ to a file.\nif content_type in [\"image/jpeg\", \"image/png\"]:\n    with\
          \ open(f\"{asset_id}\", \"wb\") as f:\n        f.write(asset)\n# Print the\
          \ asset as JSON\nelif \"text/json\" in content_type:\n    print(json.dumps(asset,\
          \ indent=2))\n"
  /v1/indexes/{index_name}/group_authorization:
    post:
      description: Update group authorization for documents, this is used in document
        level security.
      operationId: update_group_authorization_v1_indexes__index_name__group_authorization_post
      parameters:
      - in: path
        name: index_name
        required: true
        schema:
          title: Index Name
          type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/GroupAuthorizationInput'
        required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PutDocumentsResponse'
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Update group authorization for documents
      x-codeSamples:
      - lang: python
        source: "from cohere_compass import GroupAuthorizationInput\nfrom cohere_compass.clients\
          \ import CompassClient\n\nCOMPASS_API_URL = ...\nBEARER_TOKEN = ...\nINDEX_NAME\
          \ = ...\nDOCUMENT_ID = ...\nAUTHORIZED_GROUP_NAME = ...\n\ncompass_client\
          \ = CompassClient(\n    index_url=COMPASS_API_URL,\n    bearer_token=BEARER_TOKEN,\n\
          )\n\nr = compass_client.update_group_authorization(\n    index_name=INDEX_NAME,\n\
          \    group_auth_input=GroupAuthorizationInput(\n        document_ids=[DOCUMENT_ID],\n\
          \        authorized_groups=[AUTHORIZED_GROUP_NAME],\n        action=GroupAuthorizationInput.Actions.ADD,\n\
          \    ),\n)\n\nfor doc in r.results:\n    if doc.error:\n        print(f\"\
          Error processing doc: {doc.document_id}, error: {doc.error}\")\n       \
          \ continue\n    print(f\"Successfully processed doc: {doc.document_id}\"\
          )\n"
  /v1/tasks/{task_id}:
    get:
      description: Status of tasks running in background
      operationId: task_status_v1_tasks__task_id__get
      parameters:
      - in: path
        name: task_id
        required: true
        schema:
          title: Task Id
          type: string
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
        '422':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
          description: Validation Error
      summary: Get task status
  /v1/webhooks/:
    get:
      description: Trigger syncs for a specific datasources passed in as a query parameter
      operationId: on_trigger_syncs_v1_webhooks__get
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
      summary: Datasource, trigger syncs
  /v1/webhooks/auth:
    get:
      description: Initiate the authentication flow for a datasource
      operationId: auth_datasource_v1_webhooks_auth_get
      responses:
        '200':
          content:
            application/json:
              schema: {}
          description: Successful Response
      summary: Datasource, initiate auth flow
servers:
- url: /api
